import logging
import json
from .models import TravelPlan
from rest_framework import serializers
from .services.llm_service import LLMService
from .services.api_key_service import APIKeyService

logger = logging.getLogger(__name__)


class BasicTravelPlanSerializer(serializers.ModelSerializer):
    """基础序列化器 - 只包含核心字段"""
    user = serializers.HiddenField(default=serializers.CurrentUserDefault())

    class Meta:
        model = TravelPlan
        fields = [
            "id",
            "user", 
            "title",
            "itinerary",    # 包含所有行程信息（含偏好）
            "expenses",     # 费用记录
            "created_at",
        ]
        read_only_fields = ["id", "created_at", "user"]


class TravelPlanCreateSerializer(BasicTravelPlanSerializer):
    """创建序列化器 - 只需要用户输入"""
    user_input = serializers.CharField(write_only=True, required=True, max_length=500)

    class Meta(BasicTravelPlanSerializer.Meta):
        # For creation we only accept `user_input` from the client.
        # Model fields (title/itinerary/expenses) are generated by the LLM server-side.
        fields = ['user_input']
        

    def create(self, validated_data, **kwargs):
        """极简创建逻辑：用户输入 → AI生成 → 存储

        Accepts optional `user` kwarg (passed from ViewSet.perform_create).
        """
        user_input = validated_data.pop('user_input')
        user = kwargs.get('user') or self.context['request'].user
        
        # 检查用户是否配置了必要的API密钥
        api_check = APIKeyService.check_required_api_keys(user)
        if not api_check['has_required']:
            raise serializers.ValidationError({
                'api_keys': api_check['message'],
                'missing_services': api_check['missing_services']
            })
        
        # 默认值（AI生成失败时使用）
        default_title = "未命名行程"
        default_itinerary = {
            "title": default_title,
            "summary": "等待AI生成行程...",
            "daily_schedule": []
        }
        default_expenses = []

        try:
            # 调用AI服务
            llm = LLMService(user=user)
            raw_response = llm.chat(messages=[{"role": "user", "content": user_input}])
            
            # 尝试解析JSON响应并提取title
            title = default_title
            expenses = default_expenses
            itinerary = default_itinerary
            
            if raw_response:
                try:
                    # 尝试解析JSON响应
                    parsed_response = json.loads(raw_response)
                    
                    # 如果解析成功，使用解析后的数据
                    if isinstance(parsed_response, dict):
                        itinerary = parsed_response
                        
                        # 提取title
                        if 'title' in parsed_response:
                            extracted_title = parsed_response.get('title', '').strip()
                            if extracted_title:
                                title = extracted_title
                                logger.info(f"成功提取标题: {title}")
                            else:
                                logger.warning("JSON中title字段为空")
                    else:
                        logger.warning("JSON响应格式不正确，不是字典类型")
                        # 创建包含原始响应的结构化数据
                        itinerary = {
                            "title": self._extract_title_from_text(raw_response, user_input),
                            "summary": "AI生成的行程内容",
                            "raw_content": raw_response,
                            "itinerary": []
                        }
                        title = itinerary["title"]
                        
                except json.JSONDecodeError as json_err:
                    logger.warning(f"JSON解析失败，创建结构化数据: {json_err}")
                    # 如果JSON解析失败，创建包含原始文本的结构化数据
                    title = self._extract_title_from_text(raw_response, user_input)
                    itinerary = {
                        "title": title,
                        "summary": "AI生成的行程内容（原始格式）",
                        "raw_content": raw_response,
                        "itinerary": []
                    }
                
        except Exception as e:
            logger.error(f"AI生成失败: {str(e)}")
            title = default_title
            itinerary = default_itinerary
            expenses = default_expenses

        # 创建旅行计划
        return TravelPlan.objects.create(
            user=user,
            title=title,
            itinerary=itinerary,
            expenses=expenses
        )
    
    def _extract_title_from_text(self, text: str, user_input: str) -> str:
        """
        从文本响应中提取标题的备用方法
        """
        import re
        
        # 尝试从用户输入中提取关键信息生成标题
        try:
            # 提取目的地
            destination_patterns = [
                r'去([^\s，,。！!？?]+)',
                r'到([^\s，,。！!？?]+)',
                r'([^\s，,。！!？?]+)旅游',
                r'([^\s，,。！!？?]+)旅行',
                r'([^\s，,。！!？?]+)游',
                r'([^\s，,。！!？?]+)度假',
            ]
            
            destination = None
            for pattern in destination_patterns:
                match = re.search(pattern, user_input)
                if match:
                    destination = match.group(1)
                    break
            
            # 提取天数
            days_patterns = [
                r'(\d+)天',
                r'(\d+)日',
            ]
            
            days = None
            for pattern in days_patterns:
                match = re.search(pattern, user_input)
                if match:
                    days = match.group(1)
                    break
            
            # 生成标题
            if destination and days:
                # 避免重复，如果destination已经包含天数信息就不重复添加
                if days in destination:
                    title = f"{destination}"
                else:
                    title = f"{destination}{days}日游"
            elif destination:
                title = f"{destination}之旅"
            elif days:
                title = f"{days}日旅行计划"
            else:
                # 如果都提取不到，尝试从响应文本中找标题
                title_patterns = [
                    r'"title":\s*"([^"]+)"',
                    r'标题[:：]\s*([^\n\r]+)',
                    r'行程[:：]\s*([^\n\r]+)',
                ]
                
                for pattern in title_patterns:
                    match = re.search(pattern, text)
                    if match:
                        extracted = match.group(1).strip()
                        if extracted:
                            title = extracted
                            break
                else:
                    title = "智能旅行计划"
            
            logger.info(f"从文本提取标题: {title}")
            return title
            
        except Exception as e:
            logger.error(f"标题提取失败: {e}")
            return "智能旅行计划"


class TravelPlanDetailSerializer(BasicTravelPlanSerializer):
    """详情序列化器 - 直接使用模型字段"""
    class Meta(BasicTravelPlanSerializer.Meta):
        pass  # 复用基础序列化器的所有配置


class TravelPlanUpdateSerializer(serializers.ModelSerializer):
    """更新序列化器 - 极简语音更新"""
    user_input = serializers.CharField(write_only=True, required=True, max_length=500)

    class Meta:
        model = TravelPlan
        fields = ['user_input']  # 只接收用户输入
        read_only_fields = ['id', 'created_at']

    def update(self, instance, validated_data):
        """极简更新逻辑：语音输入 → AI重新生成 → 覆盖保存"""
        user_input = validated_data.get('user_input', '')
        
        try:
            # 调用AI服务重新生成
            llm = LLMService(user=self.context['request'].user)
            raw_response = llm.chat(messages=[
                {"role": "user", "content": f"用户想要修改现有行程，请基于新要求重新生成完整行程。\n\n原始行程: {json.dumps(instance.itinerary)}\n\n新要求: {user_input}"}
            ])
            
            # 尝试解析并保存结构化数据
            if raw_response:
                try:
                    # 尝试解析JSON响应
                    parsed_response = json.loads(raw_response)
                    
                    # 如果解析成功，使用解析后的数据
                    if isinstance(parsed_response, dict):
                        instance.itinerary = parsed_response
                        
                        # 提取title
                        if 'title' in parsed_response:
                            extracted_title = parsed_response.get('title', '').strip()
                            if extracted_title:
                                instance.title = extracted_title
                                logger.info(f"更新时成功提取标题: {extracted_title}")
                    else:
                        logger.warning("更新时JSON响应格式不正确，不是字典类型")
                        # 创建包含原始响应的结构化数据
                        title = self._extract_title_from_text(raw_response, user_input)
                        instance.itinerary = {
                            "title": title,
                            "summary": "AI重新生成的行程内容",
                            "raw_content": raw_response,
                            "itinerary": []
                        }
                        if title != "智能旅行计划":
                            instance.title = title
                        
                except json.JSONDecodeError:
                    # JSON解析失败时，创建包含原始文本的结构化数据
                    title = self._extract_title_from_text(raw_response, user_input)
                    instance.itinerary = {
                        "title": title,
                        "summary": "AI重新生成的行程内容（原始格式）",
                        "raw_content": raw_response,
                        "itinerary": []
                    }
                    if title != "智能旅行计划":
                        instance.title = title
            else:
                logger.warning("AI更新时返回空响应")
                
        except Exception as e:
            logger.error(f"AI更新失败: {str(e)}")
            instance.title = f"{instance.title} (更新失败)"

        instance.save()
        return instance
    
    def _extract_title_from_text(self, text: str, user_input: str) -> str:
        """
        从文本响应中提取标题的备用方法（更新时使用）
        """
        import re
        
        try:
            # 首先尝试从响应文本中找标题
            title_patterns = [
                r'"title":\s*"([^"]+)"',
                r'标题[:：]\s*([^\n\r]+)',
                r'行程[:：]\s*([^\n\r]+)',
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, text)
                if match:
                    extracted = match.group(1).strip()
                    if extracted:
                        logger.info(f"从更新响应文本提取标题: {extracted}")
                        return extracted
            
            # 如果响应中没有找到，尝试从用户输入中提取
            destination_patterns = [
                r'去(\w+)',
                r'到(\w+)',
                r'(\w+)旅游',
                r'(\w+)旅行',
                r'(\w+)游',
            ]
            
            destination = None
            for pattern in destination_patterns:
                match = re.search(pattern, user_input)
                if match:
                    destination = match.group(1)
                    break
            
            if destination:
                title = f"{destination}之旅"
                logger.info(f"从更新输入提取标题: {title}")
                return title
            
            return "智能旅行计划"
            
        except Exception as e:
            logger.error(f"更新时标题提取失败: {e}")
            return "智能旅行计划"

# 费用管理相关的序列化器
from decimal import Decimal
from .models import ExpenseEntry
from .services.budget_service import BudgetAnalyzer, ExpenseTracker


class ExpenseEntrySerializer(serializers.ModelSerializer):
    """费用条目序列化器"""
    
    class Meta:
        model = ExpenseEntry
        fields = [
            'id', 'travel_plan', 'amount', 'currency', 'category',
            'description', 'location', 'receipt_image', 'voice_note',
            'created_at', 'is_synced'
        ]
        read_only_fields = ['id', 'created_at', 'is_synced']
    
    def validate_amount(self, value):
        """验证金额"""
        if value <= 0:
            raise serializers.ValidationError("金额必须大于0")
        if value > 999999:
            raise serializers.ValidationError("金额不能超过999999")
        return value
    
    def validate_travel_plan(self, value):
        """验证旅行计划"""
        user = self.context['request'].user
        if value.user != user:
            raise serializers.ValidationError("只能为自己的旅行计划添加费用")
        return value


class ExpenseCreateSerializer(serializers.ModelSerializer):
    """创建费用条目的序列化器"""
    
    class Meta:
        model = ExpenseEntry
        fields = [
            'travel_plan', 'amount', 'currency', 'category',
            'description', 'location', 'receipt_image', 'voice_note'
        ]
    
    def validate_amount(self, value):
        """验证金额"""
        if value <= 0:
            raise serializers.ValidationError("金额必须大于0")
        return value
    
    def create(self, validated_data):
        """创建费用条目"""
        # 自动分类（如果没有指定类别）
        if not validated_data.get('category') or validated_data['category'] == 'other':
            tracker = ExpenseTracker()
            description = validated_data.get('description', '')
            amount = float(validated_data.get('amount', 0))
            validated_data['category'] = tracker.categorize_expense(description, amount)
        
        return super().create(validated_data)


class VoiceExpenseSerializer(serializers.Serializer):
    """语音费用记录序列化器"""
    
    travel_plan_id = serializers.IntegerField()
    audio_file = serializers.FileField(required=False)
    audio_data = serializers.CharField(required=False, help_text="Base64编码的音频数据")
    
    def validate(self, data):
        """验证数据"""
        if not data.get('audio_file') and not data.get('audio_data'):
            raise serializers.ValidationError("必须提供音频文件或音频数据")
        
        # 验证旅行计划
        user = self.context['request'].user
        try:
            travel_plan = TravelPlan.objects.get(
                id=data['travel_plan_id'],
                user=user
            )
            data['travel_plan'] = travel_plan
        except TravelPlan.DoesNotExist:
            raise serializers.ValidationError("旅行计划不存在或无权限访问")
        
        return data
    
    def create(self, validated_data):
        """处理语音费用记录"""
        travel_plan = validated_data['travel_plan']
        user = self.context['request'].user
        
        # 获取音频数据
        audio_data = None
        if validated_data.get('audio_file'):
            audio_data = validated_data['audio_file'].read()
        elif validated_data.get('audio_data'):
            import base64
            try:
                audio_data = base64.b64decode(validated_data['audio_data'])
            except Exception as e:
                raise serializers.ValidationError(f"音频数据解码失败: {e}")
        
        # 使用费用跟踪器处理语音
        tracker = ExpenseTracker()
        result = tracker.add_expense_from_voice(
            audio_data, 
            travel_plan.id, 
            user
        )
        
        if not result.get('success'):
            raise serializers.ValidationError(result.get('error', '语音处理失败'))
        
        return result


class BudgetAnalysisSerializer(serializers.Serializer):
    """预算分析序列化器"""
    
    travel_plan_id = serializers.IntegerField()
    
    def validate_travel_plan_id(self, value):
        """验证旅行计划ID"""
        user = self.context['request'].user
        try:
            travel_plan = TravelPlan.objects.get(id=value, user=user)
            return travel_plan
        except TravelPlan.DoesNotExist:
            raise serializers.ValidationError("旅行计划不存在或无权限访问")
    
    def create(self, validated_data):
        """执行预算分析"""
        travel_plan = validated_data['travel_plan_id']
        user = self.context['request'].user
        analyzer = BudgetAnalyzer(user=user)
        return analyzer.analyze_budget(travel_plan)


class BudgetBreakdownSerializer(serializers.Serializer):
    """预算分解序列化器"""
    
    destination = serializers.CharField(max_length=100)
    days = serializers.IntegerField(min_value=1, max_value=365)
    total_budget = serializers.DecimalField(max_digits=10, decimal_places=2, min_value=0)
    preferences = serializers.JSONField(required=False, default=dict)
    
    def create(self, validated_data):
        """生成预算分解"""
        analyzer = BudgetAnalyzer()
        requirements = {
            'destination': validated_data['destination'],
            'days': validated_data['days'],
            'total_budget': float(validated_data['total_budget']),
            'preferences': validated_data.get('preferences', {})
        }
        return analyzer.generate_budget_breakdown(requirements)


class ExpensePredictionSerializer(serializers.Serializer):
    """费用预测序列化器"""
    
    itinerary = serializers.JSONField()
    
    def create(self, validated_data):
        """预测费用"""
        analyzer = BudgetAnalyzer()
        return analyzer.predict_expenses(validated_data['itinerary'])


class BudgetStatusSerializer(serializers.Serializer):
    """预算状态序列化器"""
    
    def to_representation(self, instance):
        """自定义输出格式"""
        if isinstance(instance, dict):
            return instance
        
        # 如果是TravelPlan对象，进行预算分析
        if hasattr(instance, 'expense_entries'):
            analyzer = BudgetAnalyzer()
            analysis = analyzer.analyze_budget(instance)
            return analysis.get('budget_status', {})
        
        return instance


class ExpenseStatisticsSerializer(serializers.Serializer):
    """费用统计序列化器"""
    
    travel_plan_id = serializers.IntegerField()
    start_date = serializers.DateTimeField(required=False)
    end_date = serializers.DateTimeField(required=False)
    category = serializers.CharField(required=False)
    
    def validate_travel_plan_id(self, value):
        """验证旅行计划ID"""
        user = self.context['request'].user
        try:
            return TravelPlan.objects.get(id=value, user=user)
        except TravelPlan.DoesNotExist:
            raise serializers.ValidationError("旅行计划不存在或无权限访问")
    
    def create(self, validated_data):
        """生成费用统计"""
        travel_plan = validated_data['travel_plan_id']
        start_date = validated_data.get('start_date')
        end_date = validated_data.get('end_date')
        category = validated_data.get('category')
        
        # 构建查询
        expenses = travel_plan.expense_entries.all()
        
        if start_date:
            expenses = expenses.filter(created_at__gte=start_date)
        if end_date:
            expenses = expenses.filter(created_at__lte=end_date)
        if category:
            expenses = expenses.filter(category=category)
        
        # 统计数据
        from django.db.models import Sum, Count, Avg
        
        stats = expenses.aggregate(
            total_amount=Sum('amount'),
            count=Count('id'),
            average_amount=Avg('amount')
        )
        
        # 按类别统计
        category_stats = {}
        for cat_choice in ExpenseEntry.CATEGORY_CHOICES:
            cat_code = cat_choice[0]
            cat_expenses = expenses.filter(category=cat_code)
            cat_total = cat_expenses.aggregate(Sum('amount'))['amount__sum'] or 0
            cat_count = cat_expenses.count()
            
            category_stats[cat_code] = {
                'name': cat_choice[1],
                'total': float(cat_total),
                'count': cat_count,
                'percentage': (float(cat_total) / float(stats['total_amount'] or 1)) * 100
            }
        
        # 按日期统计
        daily_stats = []
        if expenses.exists():
            from django.db.models import TruncDate
            daily_expenses = expenses.annotate(
                date=TruncDate('created_at')
            ).values('date').annotate(
                total=Sum('amount'),
                count=Count('id')
            ).order_by('date')
            
            daily_stats = [
                {
                    'date': item['date'].isoformat(),
                    'total': float(item['total']),
                    'count': item['count']
                }
                for item in daily_expenses
            ]
        
        return {
            'summary': {
                'total_amount': float(stats['total_amount'] or 0),
                'count': stats['count'],
                'average_amount': float(stats['average_amount'] or 0)
            },
            'by_category': category_stats,
            'by_date': daily_stats,
            'period': {
                'start_date': start_date.isoformat() if start_date else None,
                'end_date': end_date.isoformat() if end_date else None
            }
        }


# API密钥管理相关序列化器
from .models import UserAPIKey, LLMAPIKey, VoiceAPIKey, MapAPIKey
from cryptography.fernet import Fernet
from django.conf import settings


class UserAPIKeySerializer(serializers.ModelSerializer):
    """用户API密钥序列化器（用于读取）"""
    
    # 不返回真实的API密钥，只返回掩码
    masked_key = serializers.SerializerMethodField()
    
    class Meta:
        model = UserAPIKey
        fields = [
            'id', 'service', 'masked_key', 'base_url', 'model_name',
            'extra_config', 'is_active', 'is_valid', 'last_validated',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'is_valid', 'last_validated', 'created_at', 'updated_at']
    
    def get_masked_key(self, obj):
        """返回掩码后的API密钥"""
        if not obj.encrypted_key:
            return ""
        
        try:
            # 解密密钥
            fernet = Fernet(settings.API_KEY_ENCRYPTION_KEY)
            decrypted_key = fernet.decrypt(obj.encrypted_key.encode()).decode()
            
            # 返回掩码版本
            if len(decrypted_key) > 8:
                return decrypted_key[:4] + '*' * (len(decrypted_key) - 8) + decrypted_key[-4:]
            else:
                return '*' * len(decrypted_key)
        except:
            return "***"


class UserAPIKeyCreateSerializer(serializers.ModelSerializer):
    """用户API密钥创建/更新序列化器"""
    
    api_key = serializers.CharField(write_only=True, required=True)
    
    is_active = serializers.BooleanField(default=True)
    extra_config = serializers.JSONField(default=dict)
    
    class Meta:
        model = UserAPIKey
        fields = [
            'service', 'api_key', 'base_url', 'model_name', 'extra_config', 'is_active'
        ]
    
    def validate_api_key(self, value):
        """验证API密钥格式"""
        if not value or len(value.strip()) < 10:
            raise serializers.ValidationError("API密钥长度不能少于10个字符")
        return value.strip()
    
    def validate_base_url(self, value):
        """验证base_url格式"""
        if value and not value.startswith(('http://', 'https://')):
            raise serializers.ValidationError("Base URL必须以http://或https://开头")
        return value
    
    def validate(self, attrs):
        """验证服务特定的字段"""
        service = attrs.get('service')
        
        if service == 'llm':
            if not attrs.get('base_url'):
                raise serializers.ValidationError({
                    'base_url': 'LLM服务需要提供Base URL'
                })
            if not attrs.get('model_name'):
                raise serializers.ValidationError({
                    'model_name': 'LLM服务需要提供模型名称'
                })
        
        elif service == 'voice':
            extra_config = attrs.get('extra_config', {})
            if not extra_config.get('app_id'):
                raise serializers.ValidationError({
                    'extra_config': '语音识别服务需要提供App ID'
                })
            if not extra_config.get('api_secret'):
                raise serializers.ValidationError({
                    'extra_config': '语音识别服务需要提供API Secret'
                })
        
        return attrs
    
    def create(self, validated_data):
        """创建API密钥"""
        api_key = validated_data.pop('api_key')
        
        try:
            # 加密API密钥
            fernet = Fernet(settings.API_KEY_ENCRYPTION_KEY)
            encrypted_key = fernet.encrypt(api_key.encode()).decode()
        except Exception as e:
            logger.error(f"API密钥加密失败: {e}")
            raise serializers.ValidationError(f"API密钥加密失败: {e}")
        
        # 获取用户
        user = self.context['request'].user
        service = validated_data['service']
        
        # 检查是否已存在相同服务的密钥
        existing_key = UserAPIKey.objects.filter(user=user, service=service).first()
        if existing_key:
            # 更新现有密钥
            for key, value in validated_data.items():
                setattr(existing_key, key, value)
            existing_key.encrypted_key = encrypted_key
            existing_key.is_valid = False  # 重置验证状态
            existing_key.save()
            return existing_key
        else:
            # 创建新密钥 - 确保不传递重复的user参数
            validated_data['user'] = user
            validated_data['encrypted_key'] = encrypted_key
            return UserAPIKey.objects.create(**validated_data)
    
    def update(self, instance, validated_data):
        """更新API密钥"""
        api_key = validated_data.pop('api_key', None)
        
        if api_key:
            # 加密新的API密钥
            fernet = Fernet(settings.API_KEY_ENCRYPTION_KEY)
            instance.encrypted_key = fernet.encrypt(api_key.encode()).decode()
            instance.is_valid = False  # 重置验证状态
        
        # 更新其他字段
        for key, value in validated_data.items():
            setattr(instance, key, value)
        
        instance.save()
        return instance

# 新的专门化API密钥序列化器

class LLMAPIKeySerializer(serializers.ModelSerializer):
    """LLM API密钥序列化器"""
    
    apikey = serializers.CharField(write_only=True, required=True)
    masked_key = serializers.SerializerMethodField()
    
    class Meta:
        model = LLMAPIKey
        fields = [
            'id', 'masked_key', 'base_url', 'model', 'max_tokens', 'temperature',
            'is_active', 'is_valid', 'last_validated', 'created_at', 'updated_at', 'apikey'
        ]
        read_only_fields = ['id', 'is_valid', 'last_validated', 'created_at', 'updated_at']
    
    def get_masked_key(self, obj):
        """返回掩码后的API密钥"""
        try:
            decrypted_key = obj.decrypt_api_key()
            if len(decrypted_key) > 8:
                return decrypted_key[:4] + '*' * (len(decrypted_key) - 8) + decrypted_key[-4:]
            else:
                return '*' * len(decrypted_key)
        except:
            return "***"
    
    def validate_apikey(self, value):
        """验证API密钥格式"""
        if not value or len(value.strip()) < 10:
            raise serializers.ValidationError("API密钥长度不能少于10个字符")
        return value.strip()
    
    def validate_base_url(self, value):
        """验证base_url格式"""
        if not value or not value.startswith(('http://', 'https://')):
            raise serializers.ValidationError("Base URL必须以http://或https://开头")
        return value
    
    def validate_temperature(self, value):
        """验证温度参数"""
        if not (0.0 <= value <= 2.0):
            raise serializers.ValidationError("温度参数必须在0.0-2.0之间")
        return value
    
    def create(self, validated_data):
        """创建LLM API密钥"""
        apikey = validated_data.pop('apikey')
        user = self.context['request'].user
        
        # 检查是否已存在
        existing_key = LLMAPIKey.objects.filter(user=user).first()
        if existing_key:
            # 更新现有密钥
            for key, value in validated_data.items():
                setattr(existing_key, key, value)
            existing_key.set_llm_config(apikey, validated_data['base_url'], validated_data['model'])
            existing_key.save()
            return existing_key
        else:
            # 创建新密钥
            instance = LLMAPIKey.objects.create(user=user, **validated_data)
            instance.set_llm_config(apikey, validated_data['base_url'], validated_data['model'])
            instance.save()
            return instance


class VoiceAPIKeySerializer(serializers.ModelSerializer):
    """语音识别 API密钥序列化器"""
    
    apikey = serializers.CharField(write_only=True, required=True)
    apisecret = serializers.CharField(write_only=True, required=True)
    masked_key = serializers.SerializerMethodField()
    masked_secret = serializers.SerializerMethodField()
    
    class Meta:
        model = VoiceAPIKey
        fields = [
            'id', 'masked_key', 'masked_secret', 'appid', 'language', 'accent',
            'is_active', 'is_valid', 'last_validated', 'created_at', 'updated_at', 
            'apikey', 'apisecret'
        ]
        read_only_fields = ['id', 'is_valid', 'last_validated', 'created_at', 'updated_at']
    
    def get_masked_key(self, obj):
        """返回掩码后的API密钥"""
        try:
            decrypted_key = obj.decrypt_api_key()
            if len(decrypted_key) > 8:
                return decrypted_key[:4] + '*' * (len(decrypted_key) - 8) + decrypted_key[-4:]
            else:
                return '*' * len(decrypted_key)
        except:
            return "***"
    
    def get_masked_secret(self, obj):
        """返回掩码后的API Secret"""
        try:
            decrypted_secret = obj.decrypt_api_secret()
            if len(decrypted_secret) > 8:
                return decrypted_secret[:4] + '*' * (len(decrypted_secret) - 8) + decrypted_secret[-4:]
            else:
                return '*' * len(decrypted_secret)
        except:
            return "***"
    
    def validate_apikey(self, value):
        """验证API密钥格式"""
        if not value or len(value.strip()) < 10:
            raise serializers.ValidationError("API密钥长度不能少于10个字符")
        return value.strip()
    
    def validate_appid(self, value):
        """验证App ID格式"""
        if not value or len(value.strip()) != 8:
            raise serializers.ValidationError("App ID长度必须为8位")
        return value.strip()
    
    def validate_apisecret(self, value):
        """验证API Secret格式"""
        if not value or len(value.strip()) < 20:
            raise serializers.ValidationError("API Secret长度不能少于20个字符")
        return value.strip()
    
    def create(self, validated_data):
        """创建语音识别 API密钥"""
        apikey = validated_data.pop('apikey')
        apisecret = validated_data.pop('apisecret')
        user = self.context['request'].user
        
        # 检查是否已存在
        existing_key = VoiceAPIKey.objects.filter(user=user).first()
        if existing_key:
            # 更新现有密钥
            for key, value in validated_data.items():
                setattr(existing_key, key, value)
            existing_key.set_voice_config(validated_data['appid'], apisecret, apikey)
            existing_key.save()
            return existing_key
        else:
            # 创建新密钥
            instance = VoiceAPIKey.objects.create(user=user, **validated_data)
            instance.set_voice_config(validated_data['appid'], apisecret, apikey)
            instance.save()
            return instance


class MapAPIKeySerializer(serializers.ModelSerializer):
    """地图服务 API密钥序列化器"""
    
    api_key = serializers.CharField(write_only=True, required=True)
    masked_key = serializers.SerializerMethodField()
    
    class Meta:
        model = MapAPIKey
        fields = [
            'id', 'masked_key', 'provider', 'base_url', 'daily_quota',
            'is_active', 'is_valid', 'last_validated', 'created_at', 'updated_at', 'api_key'
        ]
        read_only_fields = ['id', 'is_valid', 'last_validated', 'created_at', 'updated_at']
    
    def get_masked_key(self, obj):
        """返回掩码后的API密钥"""
        try:
            decrypted_key = obj.decrypt_api_key()
            if len(decrypted_key) > 8:
                return decrypted_key[:4] + '*' * (len(decrypted_key) - 8) + decrypted_key[-4:]
            else:
                return '*' * len(decrypted_key)
        except:
            return "***"
    
    def validate_api_key(self, value):
        """验证API密钥格式"""
        if not value or len(value.strip()) < 10:
            raise serializers.ValidationError("API密钥长度不能少于10个字符")
        return value.strip()
    
    def validate_daily_quota(self, value):
        """验证每日配额"""
        if value <= 0:
            raise serializers.ValidationError("每日配额必须大于0")
        return value
    
    def create(self, validated_data):
        """创建地图服务 API密钥"""
        api_key = validated_data.pop('api_key')
        user = self.context['request'].user
        
        # 检查是否已存在
        existing_key = MapAPIKey.objects.filter(user=user).first()
        if existing_key:
            # 更新现有密钥
            for key, value in validated_data.items():
                setattr(existing_key, key, value)
            existing_key.set_api_key(api_key)
            existing_key.save()
            return existing_key
        else:
            # 创建新密钥
            instance = MapAPIKey.objects.create(user=user, **validated_data)
            instance.set_api_key(api_key)
            instance.save()
            return instance


# 统一的API密钥管理序列化器
class UnifiedAPIKeySerializer(serializers.Serializer):
    """统一的API密钥管理序列化器"""
    
    service = serializers.ChoiceField(choices=[
        ('llm', 'LLM服务'),
        ('voice', '语音识别'),
        ('maps', '地图服务'),
    ])
    
    def to_representation(self, instance):
        """根据服务类型返回相应的序列化数据"""
        if hasattr(instance, 'service'):
            # 旧版UserAPIKey
            service = instance.service
        else:
            # 新版专门化模型
            if isinstance(instance, LLMAPIKey):
                service = 'llm'
            elif isinstance(instance, VoiceAPIKey):
                service = 'voice'
            elif isinstance(instance, MapAPIKey):
                service = 'maps'
            else:
                service = 'unknown'
        
        # 使用相应的序列化器
        if service == 'llm':
            if isinstance(instance, LLMAPIKey):
                serializer = LLMAPIKeySerializer(instance, context=self.context)
            else:
                serializer = UserAPIKeySerializer(instance, context=self.context)
        elif service == 'voice':
            if isinstance(instance, VoiceAPIKey):
                serializer = VoiceAPIKeySerializer(instance, context=self.context)
            else:
                serializer = UserAPIKeySerializer(instance, context=self.context)
        elif service == 'maps':
            if isinstance(instance, MapAPIKey):
                serializer = MapAPIKeySerializer(instance, context=self.context)
            else:
                serializer = UserAPIKeySerializer(instance, context=self.context)
        else:
            serializer = UserAPIKeySerializer(instance, context=self.context)
        
        data = serializer.data
        data['service'] = service
        return data